抽象類和接口的差異：

    相同點：
        1. 都是抽象形式，都可以有抽象方法，都無法創建對象。
        2. 都是子類形式：  抽象類 是被 子類 繼承使用
                          接口 是被 實現類 實現。
        3. 一個類 繼承 抽象類 or 實現接口，都必須重寫完他們的抽象方法，否則自己要成為抽象類 or 報錯
        4. 都能支持多態，都能實現解耦合

    不同點：
        1. 抽象類 中能定義全部成員
            接口  只能定義常量、抽象方法(JDK8新增的三種方法)
        2. 抽象類  只能被類單繼承
            接口   可以被多個類實現
        3. 抽象類  適用於模板設計(Design Pattern)，更利於做父類，實現代碼的複用性
            接口   適用於做功能的解耦合，模組性更強

關於static修飾：
    無static修飾，屬於 對象object 擁有的
    有static修飾，屬於 類class 擁有的

抽象類和接口的使用時機：
    抽象類：
        無法創建對象，所以只能被繼承，用來做為父類，實現代碼的重複性。
    接口：
        無法創建對象，所以使用匿名內部類，可以創建一個接口的實現類，當作一個子類來使用。

Collection <E> 集合體系結構：
    1. List ：有序、可重複、有索引
        ArrayList
        LinkedList
    2. Set： 無序、無重複、無索引
        HashSet
            LinkedHashSet："有序" 、 無重複、無索引
        TreeSet："按照大小默認升序排序"、無重複、無索引

【ArrayList】  底層是基於"數組"存儲data
    【特性】：
        1. 查詢 快
        2. 增刪 慢
     => 原先預設是給空的數組。DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
     => 是第一次添加data後，才會藉由grow()擴容。
        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
        由於DEFAULT_CAPACITY是10, 所以返回會是10作為數組的Size。
     => 當元素到11索引時，會進行第二次grow()。此時數組長度會從10 -> 15。成長1.5倍
     => 同理索引16，長度會是 15+ (15 >> 1) = 15 + 7 = 22

【LinkedList】 底層是基於"鏈表"存儲data
    【單鏈表】
        => 節點在內存中是不連續的，每個節點包含的'數據值'和'下一個節點的地址'
        【特性】：
            1. 查詢 慢 ; 無論查詢哪個數據，都需要從頭開始查詢
            2. 增刪 相對快
    【雙鏈表】
        => 節點在內存中是不連續的，每個節點包含的'數據值'和'下一個節點的地址'和'前一個節點的地址'
        【特點】：
            1. 查詢 慢
            2. 增刪 相對快。 對(首尾的元素) 增刪改查 是極快的

【哈希表ＨａｓｈＴａｂｌｅ】
    ＪＤＫ８ before ，哈希表　＝　數組　＋　鏈表
    ＪＤＫ８ after ，哈希表 ＝　數組　＋　鏈表　＋　紅黑樹
    哈希表是一種　＂增刪改查　＂，性能較好的數據結構

     【步驟】
     1. 創建一個默認長度１６的數組，默認加載因子為０.７５，數組名table
        （與ArrayList相同，也是第一次添加元素後擴容）
        （１６　＊　０.７５　＝　１２。當元素１２格填滿後，繼續往後擴容，大小會變為原先的兩倍，１６ －＞　３２）
     2. 使用每個元素的　＂哈希值　＂對　＂數組的長度做運算　＂計算該放哪個位置
     （哈希值：在ＪＡＶＡ中的對象，每個都有一個哈希值）
     （若對象的哈希值相同，此時會發生　＂哈希碰撞　＂）
     3. 判斷當前位置是否ｎｕｌｌ，
        如果是ｎｕｌｌ，則直接存入。
        反之，表示該位置存在元素，則要調equals()來確認元素是否兩者相同，
        相同，則不存入。
        不相同，存入。
        【ＪＤＫ８　before 存入數組中鏈表的方式】
            新元素直接存入數組，老元素接在鏈表。

        【ＪＤＫ８　After 存入數組中鏈表的方式】
            新元素接在鏈表。
        ( 鏈結長度 > 8 || 數組長度 >= 64 ，則鏈結自動轉成　＂紅黑樹　＂)

【LinkedHashSet】
    依舊是照著 ＂數組　＋　鏈表　＋　紅黑樹　＂。但要注意！　這邊是　＂有序　＂、　無重複　、　無索引。
    ＂有序　＂的原因就是因為是使用【雙鏈表】來記錄前、後節點。

【底層原理】
    實際上：Set集合就是由Map實現的，只是Set集合中的元素只要key值。
        HashMap與HashSet的底層原理相同，都是基於HashTable實現。
        TreeSet與TreeMap的底層原理相同，都是基於紅黑樹實現。
        LinkedHashMap的底層原理，都是基於LinkedHashSet





